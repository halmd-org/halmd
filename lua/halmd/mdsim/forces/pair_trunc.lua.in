--
-- Copyright © 2010-2011  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local device            = require("halmd.device")
local module            = require("halmd.utility.module")
local mdsim = {
    box                 = require("halmd.mdsim.box")
  , core                = require("halmd.mdsim.core")
  , neighbour           = require("halmd.mdsim.neighbour")
  , particle            = require("halmd.mdsim.particle")
  , potential           = require("halmd.mdsim.potential")
  , forces_trunc        = require("halmd.mdsim.forces.trunc")
}

-- grab modules
local forces = libhalmd.mdsim.forces
local discontinuous = assert(libhalmd.mdsim.forces.trunc.discontinuous)

-- grab standard library
local property = property
local assert = assert

local M = module("halmd.mdsim.forces.pair_trunc")

--
-- construct truncated pair force module
--
-- @param args.potential potential name
--
function M.__new(args)
    -- construct global potential module
    local potential = mdsim.potential()

    -- construct cutoff module depending on smoothing parameter
    local smooth = assert(potential.smooth)
    if smooth > 0 then
        -- use local, smooth truncation
        trunc = mdsim.forces_trunc.local_r4{h = smooth}
    else
        -- otherwise default to empty function
        trunc = discontinuous()
    end

    local particle = mdsim.particle() -- singleton
    local dimension = assert(particle.dimension)
    local box = mdsim.box() -- singleton

    -- create neighbour lists with cutoff radii of potential
    local neighbour = mdsim.neighbour{r_cut = potential.r_cut}

    -- construct force module
    local force = assert(forces.pair_trunc)(potential, particle, box, neighbour, trunc)

    local core = mdsim.core()
    -- system preparation
    core:on_append_setup(force.compute)
    -- compute forces every step
    core:on_force(force.compute)

    -- store potential Lua object (which contains the C++ object) as a
    -- read-only Lua property, so we may read it in pair_trunc.profile
    -- and retrieve the description of the potential for the log entry
    force.potential = property(function(self)
        return potential
    end)

    return force
end

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    profiler:on_profile{self, compute = "computation of " .. self.potential.module.description() .. " interaction"}
end

--
-- returns module description
--
function M.description()
    return "Truncated pair interaction"
end

return M
